library(shiny)

ui <- shinyUI(fluidPage(
  titlePanel(""),
  sidebarLayout(
    sidebarPanel(
      fileInput("data_file",
                "Select CV File",
                accept = ".csv",
                buttonLabel = "Browse..."),
      actionButton("addInput","Add a New Table"),
      uiOutput("inputs"),
      actionButton("getTexts","Generate Table(s)")
    ),
    
    # Show a plot of the generated distribution
    mainPanel(
      verbatimTextOutput("txtOut")
    )
  )))

server <- shinyServer(function(input,output,session){
  ### Generates blank value
  ids <- NULL
  
  observeEvent(input$addInput,{
    print(ids)
    
    ### Identifies if ids is still NULL, indicating no new Input has been added.
    if (is.null(ids)){
      ids <<- 1
      ### Indicates an input has been added and therefore generates a vector 
      ### with the value of ids, and ids plus 1.
    }else{
      ids <<- c(ids, max(ids)+1)
    }
    ### Not sure how lapply comes into play or tagList. I know that sprintf 
    ### allows it to increase '%d' as a number. If you use regular print, it 
    ### doesnt change the '%d' value to 1-infinity.
    output$inputs <- renderUI({
      tagList(
        lapply(1:length(ids),function(i){
          textInput(paste0("txtInput",ids[i]), sprintf("Sample Type #%d",ids[i]))
        })
      )
    })
  })
  
  observeEvent(input$getTexts,{
    ### Simply states that if it is NULL still, nothing can be generated.
    if(is.null(ids)){
      output$txtOut <- renderText({"No data tables could be generated. Please
        ensure the data you wish to insert into a table hold consistent strings
        and that you have inserted this string into the 'Data Table #' box 
        which is generated by hitting the 'Add a New Table button'. For example,
        if I have 3 CB-A samples (CB-A #1, CB-A #2, and CB-A #3), you can select
        them all by typing in 'CB-A'."})
      ### Generates empty list to be used later.
    }else{
      
      ### I believe this takes the names of the inputs and puts them into a vector.
      txtbox_ids <- sapply(1:length(ids),function(i){
        paste("txtInput",ids[i],sep="")
      })
      
      ### I believe this takes the values from the pre-established values. And
      ### just add them to a textbox.
      data <- input$data_file
      ext <- tools::file_ext(data$datapath)
      
      req(data)
      validate(need(ext == "csv", "Please confirm uploaded file extension is saved
                  in a '.csv' format."))
      data_1 <- read.csv(data$datapath, header = input$header, check.names = FALSE)
      long_data <- pivot_longer(data_1,
                                cols = !contains('Sample'),
                                names_to = "Time_Points",
                                values_to = "Number"
      )
      ### ggplot takes many toggle-able options from the user 
      ### this allows the user to format the axis titles , Graph title,
      ### aixs labels, and overall color scheme. All color schemes are cupposed to be color blind friendly
      long_data_final <- rename(long_data, 'Sample' = contains('Sample'))
      back_to_wide <- pivot_wider(long_data_final,
                                  names_from = contains('Sample'),
                                  values_from = contains('Number'))
      for(i in 1:length(txtbox_ids)){
        output$txtOut[[i]] <- renderTable({
          replicates <- back_to_wide %>%
            select(contains(input[[ txtInput[i] ]]))
          average <- as.data.frame(rowMeans(replicates)) %>%
            rename(
              Average = 'rowMeans(replicates)',
              all <- cbind(replicates, average))
        })
      }
      
      ### This simply takes the final version of 'out' renderPrints it into a
      ### new object and that output object is displayed later
    }
  })
  
})

shinyApp(ui=ui,server=server)